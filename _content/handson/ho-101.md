---
title: HO-101 Deploying APPs with ICP
weight: 1
---

## Introduction 
This part of the tutorial continues to show how you can use Kubernetes to deploy a containerized app In this scenario, the app developer deploys a Hello World version of the app into the Kubernetes cluster that the network administrator created previously.

Each lesson teaches you how to deploy progressively more complicated versions of similar apps. The diagram shows the tutorial's components of the app deployments, except the fourth part. 

The fourth part of the diagram is intended to show you how a cluster with multiple nodes might be configured.

{%
  include figure.html
  src="/assets/img/ho-101/picture1.png"
  alt=""
  caption=""
  border=false
  lightbox=false
%}

Kubernetes uses several different types of resources to get your apps up and running in clusters. In Kubernetes, deployments and services work together. Deployments include the definitions for the app, like where the image is built and which port must be exposed for the app. A minimal deployment might contain one pod, one containerized app. To make your app more resilient, you can create multiple instances of the same app by defining a replica set. If one of these replicas become unresponsive, the pod is re-created automatically.

Services include definitions for making the deployment accessible to the world. In this tutorial, you will use a public IP address that is automatically assigned to a worker node and a port to access the running version of the app.

To make your app even more highly available, in paid clusters, you can create multiple nodes to run even more replicas. This task is not covered in this tutorial, but keep this concept in mind for future improvements to an app's availability.

Only one of the lessons include incorporating Bluemix services in an app, but you can use them with as simple or complex of an app as you can imagine. 

## Objectives 
You will learn to deploy an app: 
- Understand basic Kubernetes terminology 
- Push an image to your private images registry 
- Make an app publicly accessible 
- Deploy a single instance of an app in a cluster by using a Kubernetes command and a script 
- Deploy multiple instances of an app in containers that are re-created during health checks 

## Audience 
Software developers and network administrators. 

## Lesson 1: Setting up your cluster environment
Create your Kubernetes cluster, set up your private image registry.

*1) Open a Terminal and log into you IBM Cloud Private Container Registry using the username admin and password admin*

```
docker login mycluster.icp:8500
```

## Lesson 2: Deploying single instance apps to Kubernetes clusters 
In this lesson, you deploy a single instance of the Hello World app into a cluster. 

{%
  include figure.html
  src="/assets/img/ho-101/picture2.png"
  alt=""
  caption=""
  border=false
  lightbox=false
%}

*1- Open a Terminal and log into you IBM Cloud Private Container Registry using the username admin and password admin*

```
docker login mycluster.icp:8500
```

*2) Clone or download the source code for the Hello world app to your user home directory.*

```
git clone https://github.com/IBM/container-service-getting-started-wt
```

The repository contains three versions of a similar app in folders that are named Stage1, Stage2, and Stage3. Each version contains the following files: 
- Dockerfile: The build definitions for the image
- app.js: The Hello world app
- package.json: Metadata about the app

*3) Navigate to the first app directory, Stage1.*

```
cd container-service-gettingstarted-wt/Stage1
```

*4) Build a Docker image that includes the app files of the Stage1 directory. If need to make a change to the app in the future, repeat these steps to create another version of the image.*

*5) Build the image locally and tag it with the path to your private images registry, your namespace that you created in the previous tutorial and a new image name. Tagging the image with the registry information and name tells Docker where to push the image in a later step. Use lowercase alphanumeric characters or underscores (\_) only in the image name.*

*Don't forget the period (.) at the end of the command. The period tells Docker to look inside the current directory for the Dockerfile to build the image.*

```
docker build -t mycluster.icp:8500/default/hello-world .       
```

When the build is complete, verify that you see the success message. 
Successfully built <image_id>

*6) Push the image to your private images registry.*

```
docker push mycluster.icp:8500/default/hello-world      
```

Output:  

```
The push refers to a repository [mycluster.icp:8500/default/hello-world]          
ea2ded433ac8: Pushed 
894eb973f4d3: Pushed 
788906ca2c7e: Pushed 
381c97ba7dc3: Pushed 
604c78617f34: Pushed 
fa18e5ffd316: Pushed 
0a5e2b2ddeaa: Pushed 
53c779688d06: Pushed 
60a0858edcd5: Pushed 
b6ca02dfe5e6: Pushed
1: digest: sha256:0d90cb73288113bde441ae9b8901204c212c8980d6283fb c2ae5d7cf652405 43 size: 2398

```
Wait for all the image layers to be pushed before you continue to the next step. 

*7) Create a Kubernetes deployment that is named hello-world-deployment to deploy the app to a pod in your cluster. Deployments are used to manage pods, which include containerized instances of an app. The following deployment deploys the app in single pod.*

```  
kubectl run hello-world-deployment --image=mycluster.icp:8500/default/hello-world
```

Output:

```
deployment "hello-world-deployment" created
```

Because this deployment creates only one instance of the app, the deployment creates more quickly than it does in later lessons where more than one instance of the app is created. 

*8) Make the app accessible to the world by exposing the deployment as a NodePort service. Services apply networking for the app. Because the cluster has one worker node rather than several, load balancing across worker nodes is not needed. Therefore, a NodePort can be used to provide users with external access to the app. The NodePort you expose is the port on which the worker node listens for traffic. In a later step, you see which NodePort was randomly assigned to the service.*

```
kubectl expose deployment/hello-world-deployment --type=NodePort --port=8080 --name=hello-world-service
```

Output: 

```
service "hello-world-service" exposed
```

Now that all the deployment work is done, you can check to see how everything turned out. 

*9) To test your app in a browser, get the details to form the URL.*

Get information about the service to see which NodePort was assigned.  

```
kubectl describe service hello-world-service
```

Output: 

```
Name:                     hello-world-service
Namespace:                kube-system
Labels:                   run=hello-world-deployment
Annotations:              <none>
Selector:                 run=hello-world-deployment
Type:                     NodePort
IP:                       10.0.0.193
Port:                     <unset>  8080/TCP
TargetPort:               8080/TCP
NodePort:                 <unset>  30801/TCP
Endpoints:                10.1.138.26:8080
Session Affinity:         None
External Traffic Policy:  Cluster
Events:                   <none>
Endpoints:              172.30.171.87:8080 
Session Affinity:       None No events.
```

The NodePorts are randomly assigned when they are generated with the expose command, but within 30000-32767. 
In this example, the NodePort is 30801.

*10) Log in into the IBM Cloud Private CLI using the username admin and the password passw0rd*

```
# bx pr login -a https://mycluster.icp:8443 --skip-ssl-validation
```

```
Login method invokedAPI endpoint: https://mycluster.icp:8443
Username> admin
Password> 
Authenticating...
OK
Select an account:
1. ICP Account (e771beedxxxxxxd0fab9d432a000f2f)
Enter a number> 1
Targeted account: ICP Account (e771beed75ec8fcd0fab9d432a000f2f)
```

*11) Get the public IP address for the worker node in the cluster.*

```
bx pr masters mycluster
```

*12) Open a browser and check out the app with the following URL: http://\<IP_address\>:\<NodePort\>.*

With the example values, the URL is [http://192.168.168.168:30801](http://192.168.168.168:30801). When you enter that URL in a browser, you can see the following text.

``` 
Hello world! Your app is up and running in a cluster!
```

*13) Open your IBM Cloud Private dashboard.*  

Open the following URL in a browser.  
[https://192.168.168.168:8443/](https://192.168.168.168:8443/)

*14) In the Workloads tab, you can see the resources that you created. When you are done exploring the Kubernetes dashboard, use CTRL+C to exit the proxy command.*

Congratulations! You deployed your first version of the app.  
Too many commands in this lesson? Agreed. How about using a configuration script to do some of the work for you?

To use a configuration script for the second version of the app, and to create higher availability by deploying multiple instances of that app, continue to the next lesson. 



